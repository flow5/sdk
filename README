/***********************************************************************************************************************

	Copyright (c) 2011 Paul Greyson

	Permission is hereby granted, free of charge, to any person 
	obtaining a copy of this software and associated documentation 
	files (the "Software"), to deal in the Software without 
	restriction, including without limitation the rights to use, 
	copy, modify, merge, publish, distribute, sublicense, and/or 
	sell copies of the Software, and to permit persons to whom the 
	Software is furnished to do so, subject to the following 
	conditions:

	The above copyright notice and this permission notice shall be 
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
	OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
	OTHER DEALINGS IN THE SOFTWARE.

***********************************************************************************************************************/


***** TOOLS *****

* Install

nodejs
nodelint
paperboy
https://github.com/mkitt/nodelint.tmbundle
	seems that it's necessary to symlink from the Support/bin/nodelint folder to the node lint installation location
	
TODO: list npm installs required

	npm install json-command

https://github.com/jamiew/jsonview-chrome
	
* Usage

DOT visualization

in browser:

	host/webharness.html?app=APP_NAME
	
command line:

	node nodharness.js 2>&1 >/dev/null | chrome
	
	
Chrome flags:

	/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --allow-file-access-from-files	
	
	
	
	
	
	TODO: CLEAN THIS UP

	SCHEMA

	(root): node
		type: selector|flow|subflow
		active: id 
		templates
			nodes
		children
			nodes
			alises (parser will go through templates until it finds a template with that name)
		transitions
			to: id (parser will go up until it finds a node with that name)




	subflows
		subflows allow flowchart semantics to be attached to states
		subflows are a linked series of controller actions where the result of one action triggers the next
			callbacks are async
			default behavior is to request data from the user
			client may provide a subflow controller (uses same mapping logic) to delegate subflow actions
				to examine the data model
				to request data from a server

		the subflow has a reference to the node that uses it

		logically a subflow operates within a state

		a subflow may terminate in null in which case control returns to the node
		or it may terminate in a string in which case:

		- if the node is a flow the string is used as the argument to doTransition
		- if the node is a selector the string is used as the argument to doSelection

		a special subflow called didBecomeActive is executed recursively when a node is selected or transitioned to
		this allows logic to execute before user interaction can occur

		one complex case is when an didBecomeActive subflow ends in a transition or selection. when this occurs,
		the didBecomeActive recursion is terminated becuase the transition or selection will trigger didBecomeActive
		for the newly active node

	Flow Documentation

	- each step in the flow can have:

		- selection
			legal only for selector type step
			activates a child
			no interaction with controller

		- transition
			specifies the field of the data model which is passed
				on step initialization, there's a hook to transform input parameters into a form that can be used this way
				default behavior is that the input parameters to a step are used as its model			
			passes parameters to a new step
			no interaction with controller

			transitions: {
				viewSlideshow: {
					to:'slideshow'
					value:'selection'			
				}
			}

			itemElement.addTapListener(function () {
				step.setValue('selection',list[index]);
				step.transition('viewSlideshow');		
			});


		- subflow
			delegates to the controller method of that name
			controller can do whatever it likes		
				- perform a computation
				- request user input
				- request data from a network service
				- examine the data model
			calls back with result
			result can be evaluated and further invocations can be chained into a decision tree


	flowcontroller prototype is what does everything except the delegate methods which include
		initialize
		valueChange


		static definition of a state represents the full state hierarchy at the time the state is entered


		usually transitions and conditions will not be implemented on states of type selection or flow.
		they usually are implemented
		at the leaf node level



		(maybe) group schema: state with multiple children all of which are active simultaneously
			children


			/*

			Node controllers will probably just be initialized with approprate ID etc. and get their own 
			parameter set. then they'll delegate through the singleton FlowController

			FlowController manages the flow graph
			It executions selections, transitions, subflows and arbitrary invocations on each node
			On transitions the flow controller will construct a hierarchy of NodeControllers corresponding to the
			nodes at that state. 
			For subflows and invocations the controller will delegate to client provided delegate code (NodeControllerDelegate?)
			Flow controller also manages transition state. e.g. during an async operation, the flow controller will 
			indicate that there is a transition underway to lock out further operations

			subflow rules:
				can select away from a node that contains an active subflow
				can't select or transition away from a node that has an ancestor with an active subflow



			*/